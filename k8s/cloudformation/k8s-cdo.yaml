AWSTemplateFormatVersion: '2010-09-09'
Description: 'code-dot-org kubernetes cluster aka k8s-cdo'

Parameters:
  ClusterName:
    Type: String
    Default: "code-dot-org"
    Description: "The name of the EKS cluster, canonically code-dot-org. Prefix it with your stack name for dev and testing, e.g.: my-stack-code-dot-org"

  VpcCidr:
    Type: String
    Default: 10.100.0.0/16
    Description: 'CIDR block for the VPC. Not sure what this should be? Pick a number between 10 and 245 (but not 100). Substitute your number for the 100 shown in the default value IP for each of the *Cidr params on this page. Lets say you pick 137, replace every instance of 10.100.X.Y in the CloudFormation param text boxes on this page with 10.137.X.Y.'

  PublicSubnet1Cidr:
    Type: String
    Default: 10.100.0.0/20
    Description: 'CIDR block for public subnet 1. Not sure how to set this? See the VpcCidr param description below.'

  PublicSubnet2Cidr:
    Type: String
    Default: 10.100.16.0/20
    Description: 'CIDR block for public subnet 2. Not sure how to set this? See the VpcCidr param description below.'

  PrivateSubnet1Cidr:
    Type: String
    Default: 10.100.32.0/20
    Description: 'CIDR block for private subnet 1. Not sure how to set this? See the VpcCidr param description below.'

  PrivateSubnet2Cidr:
    Type: String
    Default: 10.100.48.0/20
    Description: 'CIDR block for private subnet 2. Not sure how to set this? See the VpcCidr param description below.'

Resources:
  #=================================
  # === code-dot-org EKS Cluster ===
  #=================================

  # Create the code-dot-org Kubernetes cluster
  EKSCluster:
    Type: AWS::EKS::Cluster
    Properties:
      # ClusterName is canonically code-dot-org:
      Name: !Ref ClusterName
      RoleArn: !GetAtt EKSClusterRole.Arn
      ResourcesVpcConfig:
        SubnetIds:
          - !Ref PublicSubnet1
          - !Ref PublicSubnet2
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
        SecurityGroupIds:
          - !Ref ClusterSecurityGroup
      Version: '1.27'

  #=================================================
  # === A Fargate Profile for each k8s namespace ===
  #==================================================

  # Fargate is AWS's "serverless" provider for Kubernetes Pods.
  # It allows Pods to run without managing EC2 instances.
  # It costs about 20% more than dedicated EC2 instances, but
  # you save 33% on K8S footguns, so scientifically its a 13% win.

  # default namepace: for all your f around and find out needs
  Default:
    Type: AWS::EKS::FargateProfile
    Properties:
      ClusterName: !Ref EKSCluster
      FargateProfileName: default
      PodExecutionRoleArn: !GetAtt EKSFargatePodExecutionRole.Arn
      Subnets:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      Selectors:
        - Namespace: default

  # EVENTUALLY, when stuff is baked and we don't care as much abou costs
  # we'll want to enable more namespaces. Potentially, we could have
  # production and everything-else, or we could have a namespace per-rails-env.
  #
  # # staging namespace
  # Staging:
  #   Type: AWS::EKS::FargateProfile
  #   Properties:
  #     ClusterName: !Ref EKSCluster
  #     FargateProfileName: staging
  #     PodExecutionRoleArn: !GetAtt EKSFargatePodExecutionRole.Arn
  #     Subnets:
  #       - !Ref PrivateSubnet1
  #       - !Ref PrivateSubnet2
  #     Selectors:
  #       - Namespace: staging
  #
  # # test namespace
  # Test:
  #   Type: AWS::EKS::FargateProfile
  #   Properties:
  #     ClusterName: !Ref EKSCluster
  #     FargateProfileName: test
  #     PodExecutionRoleArn: !GetAtt EKSFargatePodExecutionRole.Arn
  #     Subnets:
  #       - !Ref PrivateSubnet1
  #       - !Ref PrivateSubnet2
  #     Selectors:
  #       - Namespace: test
  #
  # # production namespace
  # #
  # # FIXME: at a minimum, prod should have its own PrivateSubnets
  # #
  # Production:
  #   Type: AWS::EKS::FargateProfile
  #   Properties:
  #     ClusterName: !Ref EKSCluster
  #     FargateProfileName: production
  #     PodExecutionRoleArn: !GetAtt EKSFargatePodExecutionRole.Arn
  #     Subnets:
  #       - !Ref PrivateSubnet1 # FIXME: prod should have its own
  #       - !Ref PrivateSubnet2 # FIXME: prod should have its own
  #     Selectors:
  #       - Namespace: production

  # Fargate profile for ArgoCD to run on AWS Fargate
  ArgoCD:
    Type: AWS::EKS::FargateProfile
    Properties:
      ClusterName: !Ref EKSCluster
      FargateProfileName: argocd
      PodExecutionRoleArn: !GetAtt EKSFargatePodExecutionRole.Arn
      Subnets:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      Selectors:
        - Namespace: argocd

  # Fargate profile for CoreDNS and other kube-system Pods
  KubeSystem:
    Type: AWS::EKS::FargateProfile
    Properties:
      ClusterName: !Ref EKSCluster
      FargateProfileName: kube-system
      PodExecutionRoleArn: !GetAtt EKSFargatePodExecutionRole.Arn
      Subnets:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      Selectors:
        - Namespace: kube-system
          Labels:
            - Key: k8s-app
              Value: kube-dns

  # === IAM Roles for EKS & Fargate ===
  # IAM role allowing EKS to manage cluster operations
  EKSClusterRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: eks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-eks-cluster-role"

  # IAM role for Fargate Pod execution, granting permissions to manage Pods
  EKSFargatePodExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-fargate-pod-execution-role"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: eks-fargate-pods.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSFargatePodExecutionRolePolicy
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-fargate-pod-execution-role"

  # =============
  # ===  VPC  ===
  # =============

  # === Networking and VPC Configuration ===
  # Main VPC to host EKS resources
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsSupport: true
      EnableDnsHostnames: true

  # Security group for EKS Cluster networking
  ClusterSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: EKS Cluster security group
      VpcId: !Ref VPC
      Tags:
        - Key: !Sub "kubernetes.io/cluster/${ClusterName}"
          Value: owned


  # =========================
  # === PUBLIC NETWORKING ===
  # =========================

  # === Internet Gateway for Public Subnets ===
  # Gives public subnets inbound and outbound internet access
  InternetGateway:
    Type: AWS::EC2::InternetGateway

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  # === Public Routing ===
  # Public route table and route to the Internet

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC

  PublicRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref InternetGateway

  # === Public Subnets ===
  # Public subnets with ELB role for external access
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnet1Cidr
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: kubernetes.io/role/elb
          Value: '1'
        - Key: !Sub "kubernetes.io/cluster/${ClusterName}"
          Value: shared

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnet2Cidr
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: kubernetes.io/role/elb
          Value: '1'
        - Key: !Sub "kubernetes.io/cluster/${ClusterName}"
          Value: shared

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable


  # ==========================
  # === PRIVATE NETWORKING ===
  # ==========================

  # === NAT Gateway for Private Subnets ===
  # Provides private subnets outbound-only internet access
  NATGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NATGatewayEIP.AllocationId
      # Placed in a PublicSubnet so it itself can access the internet
      # and proxies outbound traffic from private subnets to PublicSubnet1
      SubnetId: !Ref PublicSubnet1

  # Allocates a public IP address to the NatGateway for outbound traffic
  NATGatewayEIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  # === Private Routing ===
  # Private route tables for each private subnet
  PrivateRouteTable1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC

  PrivateRouteTable2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC

  # Routes for private subnets to access the NAT Gateway
  PrivateRoute1:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      DestinationCidrBlock: '0.0.0.0/0'
      NatGatewayId: !Ref NATGateway

  PrivateRoute2:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable2
      DestinationCidrBlock: '0.0.0.0/0'
      NatGatewayId: !Ref NATGateway


  # === Private Subnets ===
  # Private subnets for internal services
  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnet1Cidr
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: false
      Tags:
        - Key: kubernetes.io/role/internal-elb
          Value: '1'
        - Key: !Sub "kubernetes.io/cluster/${ClusterName}"
          Value: shared

  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet1
      RouteTableId: !Ref PrivateRouteTable1

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnet2Cidr
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: false
      Tags:
        - Key: kubernetes.io/role/internal-elb
          Value: '1'
        - Key: !Sub "kubernetes.io/cluster/${ClusterName}"
          Value: shared

  PrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet2
      RouteTableId: !Ref PrivateRouteTable2


Outputs:
  ClusterName:
    Description: 'EKS Cluster Name'
    Value: !Ref EKSCluster

  ClusterEndpoint:
    Description: 'EKS Cluster Endpoint'
    Value: !GetAtt EKSCluster.Endpoint

  ClusterSecurityGroupId:
    Description: 'EKS Cluster Security Group ID'
    Value: !Ref ClusterSecurityGroup
